---
category:
  - Frontend
index : 2
title :  语言基础
author : 蛙蛙
---

## 语法

### 区分大小写

ES 中一切都区分大小写。变量 test 和 变量 Test 是两个不同的变量。typeof 不能作为函数名，而 Typeof 是一个完全有效的函数名

- 关键字、保留字、true、false 和 null 不能作为标识符。

---

### 严格模式

- 整个脚本启动严格模式，在脚本开头加上

  ```js
  "use strict";
  ```

- 也可以给单独一个函数指定严格模式

  ```js
  function doSomeThing() {
  	"use strict";
      // 函数体
  }
  ```

---

### 语句

分号不是必须的，但最好不要省略。加分号在某些情况下能提升性能，因为解析器会尝试在合适的位置补上分号来纠正语法错误。

-  关于分号是否省略，最好还是不要省略，我之前遇到过一个例子👇。如果不在`const a = 1`后面加分号，会导致解析器认为1是一个函数，抛出`VM51:2 Uncaught TypeError: 1 is not a function`的错误。

  ```js
  // Uncaught TypeError: 1 is not a function
  const a = 1
  (() => {
      console.log('IFEE')
  })()
  
  // ok！
  const a = 1;
  (() => {
      console.log('IFEE')
  })();
  ```

## 变量

有三个关键字可以声明变量：var、let 和 const。var 在 ES 的所有版本中都可以用，而 let 和 const 只能在 ES6 以及更高版本中使用。

### var 关键字

`var message`定义了一个名为 message 的变量，可以保存任何类型的值，在没有初始化的情况下，`console.log(message)`的结果为 undefined。

#### var 声明作用域

- 使用 var 定义的变量会成为包含他的函数的局部变量，在函数退出的时候会被销毁。

  ```js
  function test() {
  	var message = "hi";
  }
  test();
  console.log(message) //出错
  ```

- 在函数内定义变量的时候省略 var 操作符，可以创建一个全局变量。

  ```js
  function test() {
  	message = "hi";
  }
  test();
  console.log(message) //hi
  ```

#### var 声明提升

- 使用 var 时，下面的代码不会报错，应为使用这个关键字声明的变量会自动提升到函数作用域的顶部(但是优先级小于函数声明)

  ```js
  function foo(){
      console.log(age);
      var age = 26;
  }
  foo() //undefined
  
  等价于：
  function foo() {
      var age;
      console.log(age);
      age = 26;
  }
  foo();//undefined
  ```
  
- 反复多次使用 var 声明同一个变量也没有问题。

---

### let 声明

let 和 var 的作用差不多，但最明显的区别是：var 声明的范围是函数作用域，而 let 声明的范围是块作用域。

```js
if (true){
    var name = 'Matt';
    console.log(name); //Matt
}
console.log(name); //Matt

if(true){
    let age = 26;
    console.log(age); //26
}
console.log(age); //ReferenceError: age 没有定义
```

- let 不允许在同一个块作用域中出现冗杂（重复）声明，否则会造成报错：`SyntaxError:标识符 xx 已经声明过了`。

- let 和 var 是同一种类型的变量，他们之间的不同主要是指出变量的相关作用域如何存在

- let 声明的变量不会在作用域中被提升

  ```js
  console.log(age); //ReferenceError: age 没有定义
  int age = 26;
  ```

- 使用 let 在全局作用域中声明的变量不会成为 window 对象的属性，而 var 声明的变量会。

  ```js
  var name = "Matt";
  console.log(window.name); //Matt
  let age = 26;
  console.log(window.age); //undefined
  ```

- js 会为 for 循环中的 let 声明分别创建独立的变量实例，在 let 出现之前，for 循环定义的迭代变量会渗透到循环体外部，在使用 let 后迭代变量的作用域只存在于函数内部。

  ```js
  for(var i = 0; i < 5; i++){
      
  }
  console.log(i); //5
  
  for(var i = 0; i < 5; i++){
      setTimeOut(() => console.log(i)); //5,5,5,5,5
  }
  
  使用 let 在for循环中定义迭代变量之后：
  
  for(let i = 0; i < 5; i++){
      
  }
  console.log(i); //ReferenceError: i 没有定义
  
  for(let i = 0; i < 5; i++){
      setTimeOut(() => console.log(i)); //0,1,2,3,4
  }
  ```

---

### const 声明

- const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量的同时必须对变量进行初始化，且尝试修改 const 声明的变量的时候会导致运行时的错误

  ```js
  const age = 26;
  age = 36; // TypeError: 给常量赋值
  
  // const 也不允许重复声明
  const name = 'Matt';
  const name = 'Nicholas' // SyntaxError
  
  // const 声明的作用域也是块
  const name = 'Matt';
  if(true) {
      const name = 'Nicholas';
  }
  console.log(name); // Matt
  ```

- const 声明的限制值适用于它指向的变量的引用，如果 const 变量引用的是一个对象，那么修改对象哪不的属性不违反 const 的限制。

  ```js
  const person = {};
  person.name = 'Matt';
  ```

- 不能用 const 来声明 for 循环中的迭代变量，因为 for 循环中会存在变量的自增。

---

## 数据类型

### typeof 操作符

对一个值使用 typeof 会返回以下六种类型之一

- undefinde：表示值为定义
- boolean：表示值为布尔值
- string：表示值为字符串
- object：表示值为对象（而不是函数）或 null
- function：表示值为函数
- symbol：表示值为符号

严格来说，函数在 ES 中被认定为是对象，并不代表一种数据类型。但是函数也有自己特殊的属性。所以有必要通过 typeof 操作符来区分函数和其他对象。

---

### Undefined 类型

- Undefined类型只有一个值，就是undefined。当使用var或let声明了变量但没有初始化时，就相当于给变量赋予了undefined 值。

- 注意等于 undefined 的变量，和未声明变量的区别。使用 typeof 时，undefined 会返回 undefined，未声明变量同样会返回undefined。

  ```js
  let message;
  
  console.log(message); // undefined
  console.log(age); // 报错
  
  console.log(typeof message); // undefined
  console.log(typeof age); // undefined
  ```

- 严格来说未初始化的变量和未定义的变量存在根本性差异，但是它们都无法进行实际操作，所以使用 typeof 操作符得到的值都为 undefined。

---

### Null 类型

Null类型同样只有一个值，即 null。null 值表示一个空对象指针，所以 typeof null 会返回 "object"。undefined 值是由 null 值派生而来的。所以 `null == undefined` 返回true

---

### Boolean 类型

Boolean类型，有两个字面值true和false。虽然布尔值只有两个，但所有其他ECMAScript类型的值都有相应布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以使用Boolean()，Boolean()可以在任意类型的数据上调用，而且始终返回一个布尔值。

| 数据类型  |    转换为 true 的值    | 转化为false的值 |
| :-------: | :--------------------: | :-------------: |
|  Boolean  |          true          |      false      |
|  String   |       非空字符串       | ""（空字符串）  |
|  Number   | 非零数值（包括无穷值） |     0、NaN      |
|  Object   |        任意对象        |      null       |
| Undefined |     N/A（不存在）      |    undefined    |

- if 等流控制语句会自动执行其他类型值到布尔值的转换

---

### Number 类型

#### 整数

```js
let intNum = 59;

let octalNum1 = 070; // 八进制的56
let octalNum2 = 08; // 无效的八进制，按8处理

let hexNum1 = 0xA; // 十六进制的10

//如果字面量超出了应有的范围，就会忽略前缀，当作十进制处理
```

#### 科学技术法

```js
// 等于31250000, 3.125 作为系数，乘以 10 的 7 次幂
let num1 = 3.125e7;

// 等于0.000 000 3 
let num2 = 3e-7;
```

- ECMAScript由于使用了IEEE754数值，所以浮点数计算存在偏差，例如，0.1加0.2得到的不等于0.3。（这种错误并非ECMAScript 所独有。其他使用相同格式的语言也有这个问题）
- 如何避免这种精度问题
  - 将浮点数变为整数计算后在转化为浮点数。
  - [或者使用现成的类库](https://javascript.plainenglish.io/why-0-1-0-2-0-3-in-javascript-d7e218224a72?gi=2b1ed4703bd4)

#### NaN

- 用 0 除以任何数值在其他语言中通常都会导致错误，从而终止代码。但在**ECMAScript**中，0、+0 或者 -0 相除会返回 NaN

- 如果分子是非 0 值，分母是有符号 0 或者无符号 0，则会返回 **Infinity** 或者 **-Infinity**

- 任何涉及 NaN 的操作都会返回 NaN（例如 NaN/10）

- NaN 不等于 包括 NaN 在内的任何的值

- isNaN 函数可以判断传入的参数是否为数值

  ```javascript
  console.log(isNaN(NaN));      // true
  console.log(isNaN(10));		  // false，10是数值
  console.log(isNaN("10"));	  // false，可以转化为数值10
  console.log(isNaN("blue"));	  // true，不可以转化为数值
  console.log(isNaN(true));	  // false，可以转化为数值1
  ```

- isNaN 函数可以用于测试对象，首先会调用对象的 valueOf() 方法，然后在确定返回的值是否可以转化为数值。如果不能，再调用 toString() 方法，然后再确定返回值。

#### 数值转换

有三个函数可以将非数值转化为数值：Number()，parseFloat() 和 parseInt()。第一个可以用于任何数据类型。后两个函数主要用于将字符串转化为数值

- Number() 函数基于如下规则执行转换
  - 布尔值，true 转换为 1，false 转换为 0。
  - 数值，直接返回
  - null，返回 0
  - undefined，返回 NaN
  - 字符串，应用如下规则：
    - 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。
    - 如果字符串包含有效的浮点值格式如“1.1”，则会转化为相应的浮点值









