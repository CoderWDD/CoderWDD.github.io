---
category:
  - Database
index : 8
title : 第八章：数据库并发控制
---

# 并发操作引发的问题

- 数据不一致性：
  - 丢失修改：
    - 指两个事务T1和T2读入同一数据并修改，T2的提交结果破坏了T1提交的结果，导致T1的修改**丢失**。
  - 不可重复读：
    - 指事务T1读取数据后，事务T2对该数据执行了更新操作，使T1**无法再现**前一次读取结果。
  - 读“脏”数据：
    - 指事务T1修改了数据后，T2对其进行读取，但由于某些原因，T1对其进行**撤销**，则此时T2读取到的数据与恢复后的数据不一致，则称为**读“脏”数据**

# 并发控制的任务

并发控制就是要用正确的方式调度并发操作，使一个用户事务的执行**不受**其它事务的干扰，从而避免造成数据的不一致性。 

- 保证事务的隔离性
- 对并发操作进行**正确调度**
- 保证数据库的一致性

# 封锁及其引发的问题

## 并发控制的基本理念

- 基本方法：

  - **封锁**
  - 时间戳
  - 乐观控制法

  值得注意的是：商用的DBMS通常采用封锁方法。

## 封锁

- 作用：保证了数据的**一致性**

- 概念：
  - 指事务T在对某个数据对象（例如表、记录等）操作之前，**先向系统发出请求，对其加锁**；
  - 加锁后，事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。
- 锁的两种类型：
  - 共享锁S：可以读，加了共享锁，其他事务**还能进行读，但不能写**
  - 排它锁X：可以写，加了排它锁，其他事务就**不能再进行读与写**

##  封锁引发的问题

- 不可避免地带来额外的开销，降低了数据库性能
- 死锁
- 活锁

---

### 活锁

- 含义：即一个事务，一直处于竞争锁的状态，但**一直没有分配到锁**

  ![image-20220524222257033](https://raw.githubusercontent.com/CoderWDD/myImages/main/blog_images/image-20220524222257033.png)

- 处理策略：采用**先来先服务**的策略

---

### 死锁

- 含义：即多个事务**占用了对方**继续执行下去所需要的封锁，而且均不释放，导致多个事务均无法执行下去的状态即死锁

![image-20220524222540660](https://raw.githubusercontent.com/CoderWDD/myImages/main/blog_images/image-20220524222540660.png)

- 处理策略：
  - 预防死锁：
    - 死锁产生的原因是两个或多个事务都已封锁了一部分数据对象，然后又都请求对方事务封锁的数据对象的锁，从而出现死等待。预防死锁策略即是破坏产生死锁的条件。
  - 死锁的诊断与解除：
    - 基于死锁很少发生的**乐观**态度，允许产生死锁，定期检查系统中是否存在死锁，若存在则解除。

- 预防方案：

  - 一次封锁法：
    - 事务在执行之前，必须一次将**所有**要使用的数据对象**加锁**，否则就不能执行
    - **存在的问题**：降低了系统并发度 + 难于事先精确确定所有封锁对象

  - 顺序封锁法：
    - 预先对系统中所有数据对象规定一个统一的加锁顺序，所有事务都按这个**顺序**进行加锁
    - 存在的问题：
      - 高维护成本
      - 实现难度大：很难事先确定每一个事务要封锁哪些对象。

- 诊断方法：

  - 超时法：事务在开始执行之前，给其赋予一个期望完成的时间戳，如果事务在规定的时限内没有完成，就认为发生了死锁。

  - **事务等待图法**：用事务等待图动态反映所有事务的等待情况

    ![image-20220524223004353](https://raw.githubusercontent.com/CoderWDD/myImages/main/blog_images/image-20220524223004353.png)

    - 当事务等待图中存在**回路**时，即表明产生了死锁。

# 可串行调度

- 可串行化调度
  - 多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。
    可串行性
- 并发事务正确调度的准则；
  - 一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度

- 冲突操作：不同的事务对同一数据项的读写操作和写写操作

- 可串行化调度的充分条件：

  - 一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc’，如果Sc’是串行的，则称调度Sc为冲突可串行化的调度。

  - **一个调度是冲突可串行化，一定是可串行化的调度**
  - **冲突可串行化调度是可串行化调度的充分非必要条件。**

- 实例：

  ![image-20220524224139494](https://raw.githubusercontent.com/CoderWDD/myImages/main/blog_images/image-20220524224139494.png)

  ![](https://raw.githubusercontent.com/CoderWDD/myImages/main/blog_images/image-20220524224227474.png)

# 两段锁协议

- 问：如何运用锁才能得到一个可串行化的调度？
- 答：**遵循两段封锁协议的并发调度是是可串行化的调度**

## 封锁协议

- 含义：在对数据对象运用封锁时，需要遵循的规则集合
- 问题：
  - 何时申请封锁
  - 持锁时间
  - 何时释放封锁等

## 两段锁协议

- 含义：事务分**两个阶段**对数据项**加锁和解锁**
- 两个阶段：
  - 第一阶段：扩展阶段（申请并获得封锁）
    - 事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁。 
  - 第二阶段：收缩阶段（释放封锁）
    - 事务可以释放任何数据项上的任何类型的锁，但是在释放一个封锁之后，事务不能再申请和获得任何其它封锁。

![image-20220524224744985](https://raw.githubusercontent.com/CoderWDD/myImages/main/blog_images/image-20220524224744985.png)

- 两段锁协议也有可能发生死锁：

  ![image-20220524224853735](https://raw.githubusercontent.com/CoderWDD/myImages/main/blog_images/image-20220524224853735.png)

- 两段锁协议与防止死锁的一次封锁法

  - 一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此一次封锁法遵守两段锁协议。
  - 但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁。

# 封锁粒度

- 含义：指**封锁对象的大小**；
- 封锁对象：可以是逻辑单元或物理单元
  - 逻辑单元: 单一的属性值、列、元组、关系、索引项、整个索引、整个数据库等；
  - 物理单元：页（数据页或索引页）、物理记录等。

- 封锁粒度、系统并发度、并发控制开销三者之间**相互制约**
  - 封锁的粒度越大，数据库中的封锁对象数据就越少，系统开销则小，但是系统并发度也小；
  - 封锁的粒度越小，系统开销则变大，但由于支持更多的事务访问数据库，系统并发度变高。

## 多粒度封锁

- 为什么需要：仅一种封锁粒度**不足以**满足数据库需求
- 粒度选择原则：**考虑封锁开销和并发度两个因素**
  - 需要处理**多个关系中大量元组**的用户事务：以**数据库**为封锁单元；
  - 需要处理同一关系中大量元组的用户事务：以**关系**为封锁单元；
  - 只处理**少量元组**的用户事务：以**元组**为封锁单元。

- 两种封锁方式：
  - 显示封锁: 直接加到数据对象上的封锁；
  - 隐式封锁: 该数据对象没有独立加锁，由于其上级结点加锁而使该数据对象加上了锁；
  - 作用：具有相同效果

## 意向锁

- 概念：
  - 是隐式封锁的显式表示；
  - 如果对一个结点加意向锁，则说明该结点的子孙结点正在被加锁；
  - 对任一结点加基本锁，**必须先对它的上层结点加意向锁**；
    - eg：对元组加锁时，必须先对它所在的数据库和关系加意向锁
- 作用：提高对数据对象加锁时系统的检查效率。 

- 分类：
  - 意向共享锁(Intent Share Lock，简称IS锁)
    - 如果对一个数据对象加IS锁，表示它的后裔结点拟加S锁。
  - 意向排它锁(Intent Exclusive Lock，简称IX锁)
    - 如果对一个数据对象加IX锁，表示它的后裔结点拟加X锁。
  - 共享意向排它锁(Share Intent Exclusive Lock，简称SIX锁)
    - 如果对一个数据对象加SIX锁，表示对它加S锁，再加IX锁，即SIX = S + IX。

![image-20220524225833259](https://raw.githubusercontent.com/CoderWDD/myImages/main/blog_images/image-20220524225833259.png)

- 锁的强度：
  - 锁的强度是指它对其他锁的排斥程度。
  - 一个事务在申请封锁时以强锁代替弱锁是安全的，反之则不然。

- 具有意向锁的多粒度封锁方法：
  - 申请封锁时应该按自上而下的次序进行；
  - 释放封锁时则应该按自下而上的次序进行。
  - 优点：
    - 提高了系统的并发度；
    - 减少了加锁和解锁的开销；
- 事务T1要对关系R1加S锁：
  - 首先，对数据库加IS锁，检查是否与数据库的显式封锁冲突；
  - 其次，检查R1是否已加了不相容的锁(X或IX)；
  - 不再需要搜索和检查R1中的元组是否加了不相容的锁(X锁)。 

# 总结

![image-20220524230041319](https://raw.githubusercontent.com/CoderWDD/myImages/main/blog_images/image-20220524230041319.png)

![image-20220524230050808](https://raw.githubusercontent.com/CoderWDD/myImages/main/blog_images/image-20220524230050808.png)
