---
category:
  - Database
index : 2
title : 考试重点！！
author : 吴某人的宝贝
---

## 构造函数的定义及其调用

- 构造函数是在创建对象时，使用给定的值来将对象初始化

- 构造函数可以带参数、可以重载，同时没有返回值

- 构造函数是类的成员函数，系统约定构造函数名必须与类名相同。构造函数提供了初始化对象的一种简单的方法。

  ```c++
  class A{
  	float  x,y;
  public:
  	A(float a,float b){  
    	x=a;   
   		y=b;
  	}//构造函数，初始化对象
  	float Sum(void) {   
    	return  x+y;   
  	}
  	void Set(float a,float b) {    
    	x=a;	
    	y=b;
  	}
  	Print(void) {  
    	cout<<"x="<<x<<'\t'<<"y="<<y<<endl;
  	}
  };
  void main(void)
  {	
    A a1(2.0, 3.0);//定义时调用构造函数初始化
  	A a2(1.0,2.0);
  	a2.Set(10.0, 20.0);   //利用成员函数重新为对象赋值 
    a1.Print();
  	a2.Print();
  }
  ```

---

### 使用构造函数使需要注意的点

- 构造函数的函数名必须与类名相同。构造函数的主要作用是完成初始化对象的数据成员以及其它的初始化工作。

- 构造函数的函数名必须与类名相同。构造函数的主要作用是完成初始化对象的数据成员以及其它的初始化工作。

- 一个类可以定义若干个构造函数。当定义多个构造函数时，必须满足函数重载的原则。

- 一个类可以定义若干个构造函数。当定义多个构造函数时，必须满足函数重载的原则。

- 若定义的类要说明该类的对象时，构造函数必须是公有的成员函数。如果定义的类仅用于派生其它类时，则可将构造函数定义为保护的成员函数。

- 由于构造函数属于类的成员函数，它对私有数据成员、保护的数据成员和公有的数据成员均能进行初始化。

  ```c++
  class  A{
  	float   x,y;
  public:
  	A(float a, float b=10){  
      x=a;   
      y=b;  
    } //带参数的构造函数
  	A()	{    
      x=0;  
      y=0;
    } //不带参数的构造函数
  	void  Print(void) {	
      cout<<x<<'\t'<<y<<endl;  
    }
  };
  void main(void)
  {   A  a1, a2(20.0), a3(3.0,  7.0);
        a1.Print(); 
        a2.Print();
        a3.Print();
  }
  ```

- 每一个对象都需要有与之相对应的构造函数，若构造函数不被显式定义，则系统会帮我们补上缺省的构造函数（不会出现在代码块中），即为对象开辟了空间，但是没有初始化。

  ```c++
  class  A{
  	float  x,y;
  public:
  	A(){}	 
  	void  Print(void) {	
      cout<<x<<'\t'<<y<<endl;  
    }
  };
  
  若是如此定义的构造函数，那么在定义对象的时候只能进行如下操作：
    
    A a1,a2;
  ```

---

### 对象在什么时候会调用构造函数

- 对局部对象，静态对象，全局对象的初始化对于局部对象，每次定义对象时，都要调用构造函数。

- 对于静态对象，是在首次定义对象时，调用构造函数的，且由于对象一直存在，只调用一次构造函数。

- 对于全局对象，是在main函数执行之前调用构造函数的。

  例：

  ```c++
  class  A{
  	float   x,y;
  public:
     A(float a, float b){
       x=a;
       y=b;
       cout<<"初始化自动局部对象\n";
     }
     A(){	
       x=0;  
       y=0;  
       cout<<"初始化静态局部对象\n";
     }
     A(float  a){	
       x=a;  
       y=0;  
       cout<<"初始化全局对象\n"; 
     }
    void  Print(void){  
      cout<<x<<'\t'<<y<<endl;  
    }
  };
  A a0(100.0);//定义全局对象
  void f(void)
  {  
    cout<<" 进入f()函数\n";
    A a2(1,2);
    static  A  a3;  //初始化局部静态对象 
  }
  void main(void)
  {    
    cout<<"进入main函数\n";
    A  a1(3.0,  7.0);//定义局部自动对象
    f();    
    f();   
  }
  
  该代码运行的流程为：
    初始化全局对象->进入main函数->初始化自动局部对象->进入f()函数-初始化自动局部对象->初始化局部静态变量->进入f()函数->初始化自动局部对象
  ```

---

### 缺省的构造函数函数

- 如果构造函数没有参数，或者构造函数的所有参数都有默认值，就可以称其为缺省构造函数。

- 省的构造函数并不对所产生对象的数据成员赋初值；即新产生对象的数据成员的值是不确定的

  ```c++
    class A{
    	float  x,y;
    public:
    	A(){}//缺省的构造函数，编译器自动产生,可以不写
    	float Sum(void) {   
        return  x+y;  
      }
    	void Set(float a,float b) {    
        x=a;	
        y=b;
      }
      void Print(void) {	
        cout<<"x="<<x<<'\t'<<"y="<<y<<endl;   
      }
    };
    void main(void)
    {	
      A a1,a2;//产生对象时，自动调用缺省的构造函数，不赋值
    	a1.Set (2.0,4.0);
    	cout<<"a1:  ";
      a1.Print ();
    	cout<<"a1.sum="<<a1.Sum ()<<endl;
    	a2.Print();//打印随机值
    }
  ```

- 在定义类时，只要显式定义了一个类的构造函数，则编译器就不产生缺省的构造函数

  ```c++
  class A{
  	float x,y;
  public:
     A(float a,float b)	{	
       x=a;	y=b;	
     }
     void Print(void){	
       cout<<x<<'\t'<<y<<endl;	
     }
  };
  void main(void)
  {	
    A  a1;  //此行错误！应为不存在缺省的构造函数供其调用
  	A  a2(3.0,30.0);
  }
  ```

- 所有的对象在定义时，必须调用构造函数，不存在没有构造函数的对象

- 在类中，若定义了没有参数的构造函数，或各参数均有缺省值的构造函数也称为缺省的构造函数，缺省的构造函数只能有一个。

- 产生对象时，系统必定要调用构造函数。所以任一对象的构造函数必须唯一。

  ```c++
  class A{
  	float x,y;
  public:
    A(float a=10,float b=20){	
      x=a;
      y=b;	
    }
    A(){}
    void Print(void){	
      cout<<x<<'\t'<<y<<endl;	
    }
  };
  void main(void)
  {	
    A  a1;   //此行错误！两个函数均为缺省的构造函数，故a1对象的构造函数不唯一
  	A  a2(3.0,30.0);
  }
  ```


---

### 构造函数与new运算符

- 可以使用new运算符来动态地建立对象。建立时要自动调用构造函数，以便完成初始化对象的数据成员。最后返回这个动态对象的起始地址。

- 用new运算符产生的动态对象，在不再使用这种对象时，必须用delete运算符来释放对象所占用的存储空间

- 用new建立类的对象时，可以使用参数初始化动态空间。

  ```c++
  class  A{
  	float   x,y;
  public:
  	A(float a, float b)	{	
      x=a;
      y=b;	
    }
  	A()	{	
      x=0;  
      y=0;	
    }
  	void  Print(void)	{  
      cout<<x<<'\t'<<y<<endl;  
    }
  };
  void main(void)
  {   
    A   *pa1,*pa2;
      pa1=new  A(3.0, 5.0);//用new动态开辟对象空间，初始化
      pa2=new A;//用new动态开辟空间，调用构造函数初始化
      pa1->Print();
      pa2->Print();
      delete  pa1;  //用delete释放空间
      delete  pa2; //用delete释放空间
  }
  ```

---

### 实现类型转换的构造函数

- 同类型的对象可以相互赋值，相当于类中的数据成员相互赋值；

  ```c++
  class A{
  	float x,y;
  public:
     A(float a,float b) {
       x=a;
       y=b;
       cout<<"调用构造函数\n";
     }
     ~A()	 {	
       cout<<"调用析构函数\n";
     }
     void Print(void) {    
       cout<<x<<'\t'<<y<<endl;	
     }
  };
  void main(void)
  { 
    A  a1(1.0, 10.0); 
    a1.Print();
    a1=A(3.0 ,  30.0);  //产生临时对象，初始化并赋值后立即释放
    a1.Print();
    cout<<"退出主函数\n";
  }
  ```

- 如果直接将数据赋给对象，所赋入的数据需要强制类型转换，这种转换需要调用构造函数。

  ```c++
  class B{
  	float x;
  public:   
    B(float a) {
      x=a;  
      cout<<"调用构造函数\n";
    }
    ~B(){  
      cout<<"调用析构函数\n";
    }
    void Print(void) {    
      cout<<x<<endl;  
    }
  };
  void main(void)
  {
    B  b1(1.0) ;	
    b1.Print();
    B  b2=100;  //单个参数可以这样赋值
    b2.Print();  
    b1=10;
    b1.Print();
    cout<<"退出主函数\n";
  }
  
  ```

---

### 完成拷贝功能的构造函数

- 可以在定义一个对象的时候用另一个对象为其初始化，即构造函数的参数是另一个对象的引用，这种构造函数常为完成拷贝功能的构造函数。

- 完成拷贝功能的构造函数的一般格式为：

  ```c++
  ClassName::ClassName(ClassName  &<变量名>)
  {	
    ......//   函数体完成对应数据成员的赋值
  }
  ```

  例：

  ```c++
  class  A{
  	float   x,y;
  public:
    A(float a=0, float b=0){
      x=a;  
      y=b;
    }
    A(A &a){ //形参必须是同类型对象的引用
      x=a.x;  
      y=a.y;
    }
  };
  void main(void)
  {   
    A   a1(1.0,2.0);
    A   a2(a1); //实参是同类型的对象
  }
  ```

- 如果没有定义完成拷贝功能的构造函数，编译器自动生成一个隐含的完成拷贝功能的构造函数，依次完成类中对应数据成员的拷贝。

  ```c++
  A::A(A &a)   //隐含的具有拷贝功能的构造函数
  {
    x=a.x;
    y=a.y;
  }
  ```

  例：

  ```c++
  class  A{
  	float   x,y;
  public:
    A(float a=0, float b=0){
      x=a; 
      y=b;
      cout<<"调用了构造函数\n";
    }
    void  Print(void){
      cout<<x<<'\t'<<y<<endl;  
    }
    ~A() {
      cout<<"调用了析构函数\n";   
    }
  };
  void main(void)
  {   
    A   a1(1.0,2.0);
    A   a2(a1);
    A   a3=a1;//可以这样赋值
    a1.Print();
    a2.Print();	
    a3.Print();
  }
  ```

  

## 析构函数的定义及其调用

- 析构函数是在系统释放对象前，对对象做一些善后工作。

- 定义析构函数的格式为：

  ```c++
  ClassName::~ClassName( ){
     ......   //函数体;
  }
  ```

---

### 析构函数的特点

- 析构函数是成员函数，函数体可写在类体内，也可写在类体外。

- 析构函数是一个特殊的成员函数，函数名必须与类名相同，并在其前面加上字符"~"，以便和构造函数名相区别。

- 析构函数不能带有任何参数，不能有返回值，不指定函数类型。

- 一个类中，只能定义一个析构函数，析构函数不允许重载。

- 析构函数是在撤消对象时由系统自动调用的。

- 在程序的执行过程中，当遇到某一对象的生存期结束时，系统自动调用析构函数，然后再收回为对象分配的存储空间。

  ```c++
  class A{
  	float x,y;
  public:
    A(float a,float b){	
      x=a;
      y=b;
      cout<<"调用非缺省的构造函数\n";
    }
    A()	 {  
      x=0;  
      y=0;  
      cout<<"调用缺省的构造函数\n" ;
    }
    ~A() {	
      cout<<"调用析构函数\n";
    }
    void Print(void) {    
      cout<<x<<'\t'<<y<<endl;	
    }
  };
  void main(void)
  {	
    A  a1; 
  	A  a2(3.0,30.0);
  	cout<<"退出主函数\n";
  }
  
  该代码运行的结果为：
    
   	调用缺省的构造函数
    调用非缺省的构造函数
    退出主函数
    调用析构函数
    调用析构函数
  ```

- 在程序的执行过程中，对象如果用new运算符开辟了空间，则在类中应该定义一个析构函数，并在析构函数中使用delete删除由new分配的内存空间。因为在撤消对象时，系统自动收回为对象所分配的存储空间，而不能自动收回由new分配的动态存储空间。

  ```c++
  class Str{
  	char *Sp;    
    int Length;
  public:
  	Str(char *string){   
      if(string){	
        Length=strlen(string);
  	    Sp=new char[Length+1]; //在构造函数中将成员数据指针指向动态开辟的内存
  			strcpy(Sp,string);  //用初值为开辟的内存赋值
  		}
      else      
        Sp=0;
  	}
  	void Show(void){	
      cout<<Sp<<endl;	
    }
  	~Str()	{  
      if(Sp)	
        delete []Sp;	//析构函数，当释放对象时收回用new开辟的空间
    }
  };
  void main(void)
  {	
    Str s1("Study C++");
  	s1.Show();
  }
  ```

---

### 不同存储类型的对象调用构造函数及析构函数 

- 对于全局定义的对象（在函数外定义的对象），在程序开始执行时，调用构造函数；到程序结束时，调用析构函数。

- 对于局部定义的对象（在函数内定义的对象），当程序执行到定义对象的地方时，调用构造函数；在退出对象的作用域时，调用析构函数。

- 用static定义的局部对象，在首次到达对象的定义时调用构造函数；到程序结束时，调用析构函数

- 对于用new运算符动态生成的对象，在产生对象时调用构造函数，只有使用delete运算符来释放对象时，才调用析构函数。若不使用delete来撤消动态生成的对象，程序结束时，对象仍存在，并占用相应的存储空间，即系统不能自动地调用析构函数来撤消动态生成的对象。

  ```c++
  class  A{
  	float   x,y;
  public:
     A(float a, float b){
       x=a;
       y=b;
       cout<<"初始化自动局部对象\n";
     }
     A(){	
       x=0;  
       y=0;  
       cout<<"初始化静态局部对象\n";
     }
     A(float  a){	
       x=a;  
       y=0;  
       cout<<"初始化全局对象\n"; 
     }
     ~A(){  
       cout<<"调用析构函数"<<endl;  
     }
  };
  A  a0(100.0);//定义全局对象
  void f(void)
  {  
    cout<<" 进入f()函数\n";
    A  ab(10.0,  20.0);//定义局部自动对象
    static  A  a3;  //初始化局部静态对象 
  }
  void main(void)
  {    
    cout<<"进入main函数\n";
  	f();     	
    f();   
  }
  
  该程序运行的结果为：
    初始化全局对象
    进入main函数
    进入f()函数
    初始化自动局部对象
    初始化静态局部对象
    调用析构函数
    进入f()函数
    初始化自动局部对象
    调用析构函数
    调用析构函数
    调用析构函数
  ```

- 用new运算符来动态生成对象数组时，自动调用构造函数，而用delete运算符来释放p1所指向的对象数组占用的存储空间时，在指针变量的前面必须加上[ ]， 才能将数组元素所占用的空间全部释放。否则，只释放第0个元素所占用的空间。

  ```c++
  class  A{
  	float   x,y;
  public:
      A(float a=0, float b=0){
        x=a;  
        y=b;
        cout<<"调用了构造函数\n";
      }
      void  Print(void){  
        cout<<x<<'\t'<<y<<endl;  
      }
      ~A() {  
        cout<<"调用了析构函数\n";   
      }
  };
  void main(void)
  {   cout<<"进入main()函数\n";
      A   *pa1;
      pa1=new  A[3];//开辟数组空间
  		cout<<"\n完成开辟数组空间\n\n";
      delete  [ ]pa1;  //必须用[]删除开辟的空间
      cout<<"退出main()函数\n";
  }
  
  该程序的运行结果为：
  	进入了main()函数
    调用了构造函数
    调用了构造函数
    调用了构造函数
    完成开辟数组空间
    调用了析构函数
    调用了析构函数
    调用了析构函数
    退出main()函数
  ```

---

### 缺省的析构函数

- 若在类的定义中没有显式地定义析构函数时，则编译器自动地产生一个缺省的析构函数，其格式为：

  ```c++
  ClassName::~ClassName() { };
  ```

- 任何对象都必须有构造函数和析构函数，但在撤消对象时，要释放对象的数据成员用new运算符分配的动态空间时，必须显式地定义析构函数。 

---





## 顺序线性表概念

## 类继承的实现

## 派生类的实现

## 虚函数的实现

## 抽象类的实现

