---
category:
  - kotlin
index : 9
title : Kotlin常见问题总结
---
本页主要记录Kotlin的常见问题，涉及到Kotlin的方方面面，并会不断维护更新

- Kotlin的提高变量不可变性的作用？
  - 不可变变量可以避免许多常见的错误，比如在多线程应用中，不会因为作用域的问题，导致产生副作用和出现非预期的操作问题。

- 为什么需要使用内联高阶函数？
  - 在程序运行期间，Lambda表达式会被声明为一个对象，即在运行的时候，会为使用的每个Lambda表达式创建一个对象，因此就会导致内存的消耗和垃圾回收器的调用。而使用内联的方式，就可以避免这种情况。
    * 注意：
      * 内联函数只对高阶函数有意义，并且只对将一个函数作为一个函数的参数的高阶函数有意义，因为这样才能通过内联的方式避免在运行时创建对象。
      * 如果一个高阶函数接受多个函数作为参数，同时又不希望所有的参数都被内联，则可以在对应的参数名称前使用`noinline`关键字来实现部分参数内联的效果（这点在Java中无法实现）

- Kotlin中字段`field`与属性`property`的区别：
  - 字段：即在类中的变量，包含那些不对外开放只在内部使用的变量，并且通常该类变量都推荐为`private`
  - 属性：即扩展了`getter`和`setter`方法的字段
  - 值得注意的是，Kotlin会为根据属性是否可写自动对其实现`getter`、`setter`

- Kotlin的延迟初始化属性相关的：`lateinit`
  - 为什么需要延迟初始化属性？
    - Kotlin的空安全带来便利的同时，也给一些需要在运行过程中初始化的属性带来了不便，所以Kotlin特意引入了延迟初始化来解决这个问题
    - 对于无法在构造函数中进行初始化的属性可以使用`lateinit`关键字
  - 要使用`延迟初始化属性`有哪些限制？
    - **该属性必须在类中声明而不能在主构造函数中声明** ，因为主构造函数中的属性一定会被初始化，与延迟初始化的初衷相悖
    - **该属性不能有自定义的`getter`、`setter`**，否则编译器就不会去自动推导一个赋值操作是否可以真正对属性进行初始化了。例如：当对一个为`null`的对象使用`setter`
    - **该属性不能为空**，否则就可以将该属性赋值为`null`了，这就与延迟初始化属性的初衷相悖，也与Kotlin的空安全相悖了
    - **该属性的类型不能是在运行时可以与Java基本类型相映射的类型**，比如：Int、Double、Char类型，因为在编译为class文件后，`lateinit`仍然需要使用`null`，而对于Java的基础类型来说，是不可能使用`null`的

- 嵌套类和内部类的不同点：
  - **嵌套类在调用外部类的时候，要先实例化外部类，而内部类能直接调用外部类的方法和属性**
  - 本质上，编译器在底层生成代码时候，嵌套类和内部类生成的代码是一样的，也就是说内部类其实是比嵌套类多封装了一层而已
